<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Abundant City Policy Atlas</title>
    <script src="https://cdn.jsdelivr.net/npm/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/mapbox-gl@2.15.0/dist/mapbox-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/supercluster@7.1.5/dist/supercluster.min.js"></script>
    <link rel="stylesheet" href="/styles.css">
    <style>
        /* Map-specific overrides */
        .container {
            max-width: 1400px;
        }

        #map {
            width: 100%;
            height: 600px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .map-overlay {
            position: absolute;
            bottom: 40px;
            right: 10px;
            background: white;
            padding: 15px 20px;
            border-radius: 6px;
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
        }

        .map-overlay.active {
            display: block;
        }

        .map-overlay-header {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--color-light);
        }

        .map-overlay-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #7f8c8d;
        }

        /* Mapbox popup styling */
        .mapboxgl-popup-content {
            padding: 0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .popup-text {
            padding: 10px 15px;
            font-size: 14px;
            color: var(--color-text);
            cursor: pointer;
            background: white;
        }

        .popup-text:hover {
            background: var(--color-light);
        }

        @media (max-width: 768px) {
            #map {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="banner.svg" alt="The Abundant City Policy Atlas - Changing Cities By Design" class="banner-img">
            <div class="header-overlay">
                <a href="/about" class="about-link">About</a>
            </div>
            <!-- Hidden text for accessibility -->
            <div class="sr-only">
                <h1>The Abundant City Policy Atlas</h1>
                <p>Changing Cities By Design</p>
            </div>
        </header>

        <div class="main-content">
            <!-- SIDEBAR FILTERS -->
            <aside class="filters-panel">
                <h2>Filters</h2>

                <!-- Policy Domain Filter (Multi-select Checkboxes) -->
                <div class="filter-group">
                    <label>Policy Domain</label>
                    <div class="checkbox-group">
                        <!-- Populated by JavaScript from database -->
                    </div>
                </div>

                <!-- Jurisdiction Type Filter -->
                <div class="filter-group">
                    <label>Jurisdiction Type</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="placeTypeCheckbox" value="state"> States</label>
                        <label><input type="checkbox" class="placeTypeCheckbox" value="county"> Counties</label>
                        <label><input type="checkbox" class="placeTypeCheckbox" value="city" checked> Cities</label>
                    </div>
                </div>

                <!-- Region/State Filter (Hierarchical) -->
                <div class="filter-group">
                    <label>Location</label>
                    <div class="checkbox-group" id="locationCheckboxes">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Date Range Filter -->
                <div class="filter-group">
                    <label>Adoption Date Range</label>
                    <div class="date-range-inputs">
                        <input type="number" id="fromYear" placeholder="From" min="1900" max="2100" class="date-range-input">
                        <span>to</span>
                        <input type="number" id="toYear" placeholder="To" min="1900" max="2100" class="date-range-input">
                    </div>
                    <label class="date-checkbox-label">
                        <input type="checkbox" id="includeUnknownDates" checked>
                        <span>Include unknown dates</span>
                    </label>
                </div>

                <!-- Status Filter -->
                <div class="filter-group">
                    <label>Reform Status</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="statusCheckbox" value="adopted" checked> Adopted</label>
                        <label><input type="checkbox" class="statusCheckbox" value="proposed"> Proposed</label>
                        <label><input type="checkbox" class="statusCheckbox" value="failed"> Failed</label>
                    </div>
                </div>

                <!-- Population Filter (Range Slider) -->
                <div class="filter-group">
                    <label>Population Range</label>
                    <div class="dual-slider-container">
                        <div class="dual-slider-track">
                            <div class="dual-slider-fill" id="sliderFill"></div>
                            <input type="range" id="minPopulation" class="dual-slider-handle" min="0" max="10000000" value="0" step="10000">
                            <input type="range" id="maxPopulation" class="dual-slider-handle" min="0" max="10000000" value="10000000" step="10000">
                        </div>
                        <div class="slider-values">
                            <span id="minPopulationLabel">0</span>
                            <span id="maxPopulationLabel">10,000,000</span>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="filter-buttons">
                    <button class="btn btn-primary" id="applyFilters">Apply Filters</button>
                    <button class="btn btn-secondary" id="resetFilters">Reset</button>
                    <button class="btn btn-secondary" id="shareSearch">üîó Share Search</button>
                </div>
            </aside>

            <!-- MAIN CONTENT -->
            <div class="content-area">
                <div id="errorMessage" class="error-message container-hidden"></div>

                <!-- View Tabs -->
                <div class="view-tabs">
                    <button class="view-tab active" id="listViewTab">üìã List View</button>
                    <button class="view-tab" id="mapViewTab">üó∫Ô∏è Map View</button>
                </div>

                <!-- Results Info -->
                <div id="resultsInfo" class="results-info container-hidden">
                    <p>Found <strong id="resultCount">0</strong> reforms matching your filters</p>
                    <button class="share-banner-btn" id="shareBannerBtn" title="Share this search">üîó</button>
                </div>

                <!-- Loading Spinner -->
                <div id="loadingSpinner" class="loading container-hidden">
                    <div class="loading-spinner"></div>
                    <p>Loading reforms...</p>
                </div>

                <!-- LIST VIEW -->
                <div id="listView" class="view-container active">
                    <div id="reformsList" class="reforms-list"></div>
                    <div id="noResultsList" class="no-results container-hidden">
                        <h3>No Reforms Found</h3>
                        <p>Try adjusting your filters to see more results.</p>
                    </div>
                </div>

                <!-- MAP VIEW -->
                <div id="mapView" class="view-container">
                    <div id="map"></div>
                    <div id="mapOverlay" class="map-overlay">
                        <button class="map-overlay-close" id="closeOverlay">‚úï</button>
                        <div class="map-overlay-header" id="overlayHeader"></div>
                        <div id="overlayCards" class="reforms-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let allReforms = [];
        let filteredReforms = [];
        let map = null;
        let mapMarkers = {};
        let clusterIndex = null;
        let reformsGeoJSON = [];
        const REGIONS = {
            'Northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'Rhode Island', 'Vermont', 'New Jersey', 'New York', 'Pennsylvania'],
            'Midwest': ['Illinois', 'Indiana', 'Michigan', 'Ohio', 'Wisconsin', 'Iowa', 'Kansas', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'South Dakota'],
            'South': ['Delaware', 'Florida', 'Georgia', 'Maryland', 'North Carolina', 'South Carolina', 'Virginia', 'West Virginia', 'Alabama', 'Kentucky', 'Mississippi', 'Tennessee', 'Arkansas', 'Louisiana', 'Oklahoma', 'Texas', 'District of Columbia'],
            'West': ['Arizona', 'Colorado', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Utah', 'Wyoming', 'Alaska', 'California', 'Hawaii', 'Oregon', 'Washington']
        };

        // ============================================================================
        // UI ELEMENTS
        // ============================================================================

        const reformTypeCheckboxes = document.querySelectorAll('.reformTypeCheckbox');
        const placeTypeCheckboxes = document.querySelectorAll('.placeTypeCheckbox');
        const statusCheckboxes = document.querySelectorAll('.statusCheckbox');
        const minPopulationSlider = document.getElementById('minPopulation');
        const maxPopulationSlider = document.getElementById('maxPopulation');
        const minPopulationLabel = document.getElementById('minPopulationLabel');
        const maxPopulationLabel = document.getElementById('maxPopulationLabel');
        const locationCheckboxes = document.getElementById('locationCheckboxes');
        const fromYear = document.getElementById('fromYear');
        const toYear = document.getElementById('toYear');
        const includeUnknownDates = document.getElementById('includeUnknownDates');
        const applyFiltersBtn = document.getElementById('applyFilters');
        const resetFiltersBtn = document.getElementById('resetFilters');
        const reformsList = document.getElementById('reformsList');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resultsInfo = document.getElementById('resultsInfo');
        const resultCount = document.getElementById('resultCount');
        const noResultsList = document.getElementById('noResultsList');
        const errorMessage = document.getElementById('errorMessage');
        const listViewTab = document.getElementById('listViewTab');
        const mapViewTab = document.getElementById('mapViewTab');
        const listView = document.getElementById('listView');
        const mapView = document.getElementById('mapView');
        const mapOverlay = document.getElementById('mapOverlay');
        const closeOverlayBtn = document.getElementById('closeOverlay');

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        applyFiltersBtn.addEventListener('click', applyFilters);
        resetFiltersBtn.addEventListener('click', resetFilters);
        listViewTab.addEventListener('click', () => switchView('list'));
        mapViewTab.addEventListener('click', () => switchView('map'));
        closeOverlayBtn.addEventListener('click', () => mapOverlay.classList.remove('active'));
        
        // Share Search button (combined save + share functionality)
        const shareSearchBtn = document.getElementById('shareSearch');
        shareSearchBtn.addEventListener('click', shareSearch);
        
        // Share button in results banner
        const shareBannerBtn = document.getElementById('shareBannerBtn');
        shareBannerBtn.addEventListener('click', shareSearch);

        // Population slider synchronization and fill update
        function updateSliderFill() {
            const min = parseInt(minPopulationSlider.value);
            const max = parseInt(maxPopulationSlider.value);
            const minPercent = (min / 10000000) * 100;
            const maxPercent = (max / 10000000) * 100;
            const fill = document.getElementById('sliderFill');
            if (fill) {
                fill.style.left = minPercent + '%';
                fill.style.width = (maxPercent - minPercent) + '%';
            }
        }

        // Add active class on mousedown to raise z-index
        minPopulationSlider.addEventListener('mousedown', () => {
            minPopulationSlider.classList.add('active');
            maxPopulationSlider.classList.remove('active');
        });

        maxPopulationSlider.addEventListener('mousedown', () => {
            maxPopulationSlider.classList.add('active');
            minPopulationSlider.classList.remove('active');
        });

        // Remove active class on mouseup
        document.addEventListener('mouseup', () => {
            minPopulationSlider.classList.remove('active');
            maxPopulationSlider.classList.remove('active');
        });

        minPopulationSlider.addEventListener('input', () => {
            const minVal = parseInt(minPopulationSlider.value);
            const maxVal = parseInt(maxPopulationSlider.value);
            if (minVal > maxVal) {
                maxPopulationSlider.value = minVal;
            }
            updatePopulationLabels();
            updateSliderFill();
        });

        maxPopulationSlider.addEventListener('input', () => {
            const minVal = parseInt(minPopulationSlider.value);
            const maxVal = parseInt(maxPopulationSlider.value);
            if (maxVal < minVal) {
                minPopulationSlider.value = maxVal;
            }
            updatePopulationLabels();
            updateSliderFill();
        });

        // ============================================================================
        // FUNCTIONS
        // ============================================================================

        // ============================================================================
        // URL/FILTER CONVERSION UTILITIES
        // ============================================================================

        function getFilterConfig() {
            const reformTypes = getSelectedReformTypes();
            const placeTypes = getSelectedPlaceTypes();
            const statuses = getSelectedStatuses();
            const minPopulation = parseInt(minPopulationSlider.value);
            const maxPopulation = parseInt(maxPopulationSlider.value);
            const states = getSelectedLocations();
            const fromYearVal = fromYear.value ? parseInt(fromYear.value) : null;
            const toYearVal = toYear.value ? parseInt(toYear.value) : null;
            const includeUnknown = includeUnknownDates.checked;

            return {
                reform_types: reformTypes,
                place_types: placeTypes,
                statuses: statuses,
                min_population: minPopulation > 0 ? minPopulation : null,
                max_population: maxPopulation < 10000000 ? maxPopulation : null,
                states: states,
                from_year: fromYearVal,
                to_year: toYearVal,
                include_unknown_dates: includeUnknown
            };
        }

        function filterConfigToUrlParams(config) {
            const params = new URLSearchParams();
            (config.reform_types || []).forEach(t => params.append('reform_type', t));
            (config.place_types || []).forEach(t => params.append('place_type', t));
            (config.statuses || []).forEach(s => params.append('status', s));
            if (config.min_population) params.append('min_population', config.min_population);
            if (config.max_population && config.max_population < 10000000) params.append('max_population', config.max_population);
            (config.states || []).forEach(s => params.append('state', s));
            if (config.from_year) params.append('from_year', config.from_year);
            if (config.to_year) params.append('to_year', config.to_year);
            if (config.include_unknown_dates) params.append('include_unknown_dates', 'true');
            return params;
        }

        function urlParamsToFilterConfig(urlSearchParams) {
            // Handle both URLSearchParams object and plain object
            const getMultiValue = (key) => {
                if (urlSearchParams instanceof URLSearchParams) {
                    return urlSearchParams.getAll(key);
                } else {
                    const val = urlSearchParams[key];
                    if (!val) return [];
                    if (Array.isArray(val)) return val.filter(Boolean);
                    return val.split(',').map(v => v.trim()).filter(Boolean);
                }
            };

            const getValue = (key) => {
                if (urlSearchParams instanceof URLSearchParams) {
                    return urlSearchParams.get(key);
                } else {
                    return urlSearchParams[key];
                }
            };

            return {
                reform_types: getMultiValue('reform_type'),
                place_types: getMultiValue('place_type'),
                statuses: getMultiValue('status'),
                min_population: getValue('min_population') ? parseInt(getValue('min_population')) : null,
                max_population: getValue('max_population') ? parseInt(getValue('max_population')) : null,
                states: getMultiValue('state'),
                from_year: getValue('from_year') ? parseInt(getValue('from_year')) : null,
                to_year: getValue('to_year') ? parseInt(getValue('to_year')) : null,
                include_unknown_dates: getValue('include_unknown_dates') === 'true'
            };
        }

        function applyFilterConfig(config) {
            // Apply reform types
            document.querySelectorAll('.reformTypeCheckbox').forEach(cb => {
                cb.checked = config.reform_types && config.reform_types.includes(cb.value);
            });
            // Update category checkboxes based on children
            document.querySelectorAll('.category-cb').forEach(cb => {
                const category = cb.dataset.category;
                const children = document.querySelectorAll(`.reformTypeCheckbox[data-category="${category}"]`);
                const allChecked = Array.from(children).every(child => child.checked);
                const someChecked = Array.from(children).some(child => child.checked);
                cb.checked = allChecked;
                cb.indeterminate = someChecked && !allChecked;
            });

            // Apply place types
            placeTypeCheckboxes.forEach(cb => {
                cb.checked = config.place_types && config.place_types.includes(cb.value);
            });

            // Apply statuses
            statusCheckboxes.forEach(cb => {
                cb.checked = config.statuses && config.statuses.includes(cb.value);
            });

            // Apply locations
            document.querySelectorAll('#locationCheckboxes input[type="checkbox"]').forEach(cb => {
                if (cb.dataset.state) {
                    cb.checked = config.states && config.states.includes(cb.dataset.state);
                }
            });
            // Update region checkboxes
            Object.keys(REGIONS).forEach(region => {
                const regionCheckbox = document.querySelector(`input[data-region="${region}"]:not([data-state])`);
                if (regionCheckbox) {
                    const stateCheckboxes = document.querySelectorAll(`input[data-state][data-region="${region}"]`);
                    const allChecked = Array.from(stateCheckboxes).every(cb => cb.checked);
                    const someChecked = Array.from(stateCheckboxes).some(cb => cb.checked);
                    regionCheckbox.checked = allChecked;
                    regionCheckbox.indeterminate = someChecked && !allChecked;
                }
            });

            // Apply population
            minPopulationSlider.value = config.min_population || 0;
            maxPopulationSlider.value = config.max_population || 10000000;
            updatePopulationLabels();
            updateSliderFill();

            // Apply dates
            fromYear.value = config.from_year || '';
            toYear.value = config.to_year || '';
            includeUnknownDates.checked = config.include_unknown_dates !== false;
        }

        function updatePopulationLabels() {
            const min = parseInt(minPopulationSlider.value);
            const max = parseInt(maxPopulationSlider.value);
            minPopulationLabel.textContent = min.toLocaleString();
            maxPopulationLabel.textContent = max.toLocaleString();
            updateSliderFill();
        }

        async function initializeReformTypeFilter() {
            try {
                const response = await fetch('/.netlify/functions/get-reform-types');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch reform types');
                }

                const container = document.querySelector('.filter-group .checkbox-group');
                container.innerHTML = '';

                // Group Types by Category
                const byCategory = {};
                data.reformTypes.forEach(rt => {
                    const cat = rt.category || 'Other';
                    if (!byCategory[cat]) byCategory[cat] = [];
                    byCategory[cat].push(rt);
                });

                // Define order
                const catOrder = ['Parking', 'Housing Typology', 'Zoning Category', 'Physical Dimension', 'Process', 'Building Code', 'Other'];

                // Render Groups
                catOrder.forEach(cat => {
                    if (!byCategory[cat]) return;

                    // 1. Create Header (Chevron + Checkbox + Label)
                    const catHeader = document.createElement('div');
                    catHeader.className = 'category-header'; // Reuses region-header style via CSS

                    // Chevron
                    const chevron = document.createElement('span');
                    chevron.className = 'chevron chevron-collapsed';
                    chevron.textContent = '‚ñº';
                    
                    // Label wrapper
                    const labelGroup = document.createElement('label');
                    labelGroup.className = 'category-group';
                    
                    // Parent Checkbox
                    const parentCb = document.createElement('input');
                    parentCb.type = 'checkbox';
                    parentCb.className = 'category-cb';
                    parentCb.checked = true;
                    parentCb.dataset.category = cat;
                    parentCb.addEventListener('change', (e) => updateReformHierarchy(e.target));

                    labelGroup.appendChild(parentCb);
                    labelGroup.appendChild(document.createTextNode(' ' + cat));

                    catHeader.appendChild(chevron);
                    catHeader.appendChild(labelGroup);
                    container.appendChild(catHeader);

                    // 2. Create Reform Items Container (Hidden by default)
                    const reformsContainer = document.createElement('div');
                    reformsContainer.className = 'reforms-container container-hidden';

                    // Items
                    byCategory[cat].forEach(rt => {
                        const label = document.createElement('label');
                        label.className = 'reform-item';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'reformTypeCheckbox';
                        checkbox.value = rt.code;
                        checkbox.checked = true;
                        checkbox.dataset.category = cat;
                        checkbox.dataset.color = rt.color_hex;
                        checkbox.addEventListener('change', (e) => updateCategoryCheckbox(e.target));
                        
                        // Color indicator
                        if (rt.color_hex) {
                           label.style.borderLeft = `3px solid ${rt.color_hex}`;
                           label.classList.add('reform-item-color-indicator');
                        }

                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(' ' + rt.name));
                        reformsContainer.appendChild(label);
                    });
                    
                    container.appendChild(reformsContainer);

                    // Toggle click handler
                    chevron.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = reformsContainer.classList.contains('container-hidden');
                        if (isHidden) {
                            reformsContainer.classList.remove('container-hidden');
                            reformsContainer.classList.add('reforms-container-visible');
                            chevron.classList.remove('chevron-collapsed');
                            chevron.classList.add('chevron-expanded');
                        } else {
                            reformsContainer.classList.add('container-hidden');
                            reformsContainer.classList.remove('reforms-container-visible');
                            chevron.classList.add('chevron-collapsed');
                            chevron.classList.remove('chevron-expanded');
                        }
                    });
                });
            } catch (error) {
                console.error('Error loading reform types:', error);
                showError('Failed to load reform types');
            }
        }

        function getSelectedReformTypes() {
            const checkboxes = document.querySelectorAll('.reformTypeCheckbox');
            const selected = [];
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedPlaceTypes() {
            const selected = [];
            placeTypeCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedStatuses() {
            const selected = [];
            statusCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedLocations() {
            const checkboxes = document.querySelectorAll('#locationCheckboxes input[data-state]:checked');
            const states = [];
            checkboxes.forEach(cb => {
                if (cb.dataset.state) {
                    states.push(cb.dataset.state);
                }
            });
            return states;
        }

        function updateLocationHierarchy(regionCheckbox) {
            const region = regionCheckbox.dataset.region;
            const states = REGIONS[region];
            const stateCheckboxes = document.querySelectorAll(
                `#locationCheckboxes input[data-state][data-region="${region}"]`
            );

            stateCheckboxes.forEach(cb => {
                cb.checked = regionCheckbox.checked;
            });
        }

        function updateRegionCheckbox(stateCheckbox) {
            const region = stateCheckbox.dataset.region;
            const regionCheckbox = document.querySelector(
                `#locationCheckboxes input[data-region="${region}"]:not([data-state])`
            );

            if (!regionCheckbox) return;

            const stateCheckboxes = document.querySelectorAll(
                `#locationCheckboxes input[data-state][data-region="${region}"]`
            );
            const allChecked = Array.from(stateCheckboxes).every(cb => cb.checked);
            const someChecked = Array.from(stateCheckboxes).some(cb => cb.checked);

            regionCheckbox.checked = allChecked;
            regionCheckbox.indeterminate = someChecked && !allChecked;
        }

        // --- Reform Type Hierarchy Helpers ---

        function updateReformHierarchy(categoryCheckbox) {
            const category = categoryCheckbox.dataset.category;
            const reformCheckboxes = document.querySelectorAll(
                `.reformTypeCheckbox[data-category="${category}"]`
            );

            reformCheckboxes.forEach(cb => {
                cb.checked = categoryCheckbox.checked;
            });
        }

        function updateCategoryCheckbox(reformCheckbox) {
            const category = reformCheckbox.dataset.category;
            // Find parent category checkbox (it has data-category but NOT class 'reformTypeCheckbox' in my new design, 
            // or I can give it a specific class like 'category-cb')
            const categoryCheckbox = document.querySelector(
                `input.category-cb[data-category="${category}"]`
            );

            if (!categoryCheckbox) return;

            const siblings = document.querySelectorAll(
                `.reformTypeCheckbox[data-category="${category}"]`
            );
            const allChecked = Array.from(siblings).every(cb => cb.checked);
            const someChecked = Array.from(siblings).some(cb => cb.checked);

            categoryCheckbox.checked = allChecked;
            categoryCheckbox.indeterminate = someChecked && !allChecked;
        }

        function initializeLocationFilter() {
            locationCheckboxes.innerHTML = '';

            Object.keys(REGIONS).forEach(region => {
                // Region container
                const regionHeader = document.createElement('div');
                regionHeader.className = 'region-header';
                
                // Region checkbox label
                const regionLabel = document.createElement('label');
                regionLabel.className = 'region-group';
                const regionCheckbox = document.createElement('input');
                regionCheckbox.type = 'checkbox';
                regionCheckbox.dataset.region = region;
                regionCheckbox.addEventListener('change', (e) => updateLocationHierarchy(e.target));
                regionLabel.appendChild(regionCheckbox);
                regionLabel.appendChild(document.createTextNode(' ' + region));
                
                // Chevron toggle
                const chevron = document.createElement('span');
                chevron.className = 'chevron chevron-collapsed';
                chevron.textContent = '‚ñº';
                
                // Header gets chevron + label (chevron on left)
                regionHeader.appendChild(chevron);
                regionHeader.appendChild(regionLabel);
                locationCheckboxes.appendChild(regionHeader);

                // States container (hidden by default)
                const statesContainer = document.createElement('div');
                statesContainer.className = 'states-container container-hidden';

                REGIONS[region].forEach(state => {
                    const stateLabel = document.createElement('label');
                    stateLabel.className = 'state-item';
                    const stateCheckbox = document.createElement('input');
                    stateCheckbox.type = 'checkbox';
                    stateCheckbox.dataset.state = state;
                    stateCheckbox.dataset.region = region;
                    stateCheckbox.addEventListener('change', (e) => updateRegionCheckbox(e.target));
                    stateLabel.appendChild(stateCheckbox);
                    stateLabel.appendChild(document.createTextNode(' ' + state));
                    statesContainer.appendChild(stateLabel);
                });
                
                locationCheckboxes.appendChild(statesContainer);

                // Toggle click handler
                chevron.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = statesContainer.classList.contains('container-hidden');
                    if (isHidden) {
                        statesContainer.classList.remove('container-hidden');
                        statesContainer.classList.add('states-container-visible');
                        chevron.classList.remove('chevron-collapsed');
                        chevron.classList.add('chevron-expanded');
                    } else {
                        statesContainer.classList.add('container-hidden');
                        statesContainer.classList.remove('states-container-visible');
                        chevron.classList.add('chevron-collapsed');
                        chevron.classList.remove('chevron-expanded');
                    }
                });
            });
        }

        async function applyFilters(skipUrlUpdate = false) {
            const reformTypes = getSelectedReformTypes();
            const placeTypes = getSelectedPlaceTypes();
            const statuses = getSelectedStatuses();
            const minPopulation = parseInt(minPopulationSlider.value);
            const maxPopulation = parseInt(maxPopulationSlider.value);
            const states = getSelectedLocations();
            const fromYearVal = fromYear.value ? parseInt(fromYear.value) : null;
            const toYearVal = toYear.value ? parseInt(toYear.value) : null;
            const includeUnknown = includeUnknownDates.checked;

            showLoading(true);
            hideError();

            try {
                // Build query string
                const params = new URLSearchParams();
                reformTypes.forEach(t => params.append('reform_type', t));
                placeTypes.forEach(t => params.append('place_type', t));
                statuses.forEach(s => params.append('status', s));
                if (minPopulation > 0) params.append('min_population', minPopulation);
                if (maxPopulation < 10000000) params.append('max_population', maxPopulation);
                states.forEach(s => params.append('state', s));
                if (fromYearVal) params.append('from_year', fromYearVal);
                if (toYearVal) params.append('to_year', toYearVal);
                if (includeUnknown) params.append('include_unknown_dates', 'true');

                const query = params.toString();
                const url = query ? `/.netlify/functions/get-reforms?${query}` : '/.netlify/functions/get-reforms';

                // Update URL without reloading page
                if (!skipUrlUpdate) {
                    const newUrl = query 
                        ? `${window.location.pathname}?${query}` 
                        : window.location.pathname;
                    window.history.pushState({}, '', newUrl);
                }

                // Fetch reforms
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch reforms');
                }

                allReforms = data.reforms;
                filteredReforms = allReforms;

                renderReforms();
                showLoading(false);

                if (filteredReforms.length > 0) {
                    resultsInfo.classList.remove('container-hidden');
                    resultsInfo.classList.add('results-info-visible');
                    resultCount.textContent = filteredReforms.length;
                    noResultsList.classList.add('container-hidden');
                } else {
                    resultsInfo.classList.add('container-hidden');
                    resultsInfo.classList.remove('results-info-visible');
                    noResultsList.classList.remove('container-hidden');
                }

            } catch (error) {
                console.error('Error:', error);
                showError(error.message);
                showLoading(false);
                resultsInfo.classList.add('container-hidden');
                noResultsList.classList.remove('container-hidden');
            }
        }

        function resetFilters() {
            // Reset checkboxes
            document.querySelectorAll('.reformTypeCheckbox').forEach(cb => cb.checked = true);
            document.querySelectorAll('.category-cb').forEach(cb => {
                cb.checked = true;
                cb.indeterminate = false;
            });
            placeTypeCheckboxes.forEach(cb => {
                cb.checked = cb.value === 'city';
            });
            statusCheckboxes.forEach(cb => {
                cb.checked = cb.value === 'adopted';
            });
            document.querySelectorAll('#locationCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = false);

            // Reset sliders
            minPopulationSlider.value = 0;
            maxPopulationSlider.value = 10000000;
            updatePopulationLabels();

            // Reset date range
            fromYear.value = '';
            toYear.value = '';
            includeUnknownDates.checked = true;

            // Clear URL params
            window.history.pushState({}, '', window.location.pathname);
            applyFilters(true);
        }

        // ============================================================================
        // SHARE SEARCH FUNCTION (combines save + share)
        // ============================================================================

        async function shareSearch() {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:830',message:'shareSearch called',data:{hasClipboard:!!navigator.clipboard,hasWriteText:!!(navigator.clipboard&&navigator.clipboard.writeText),isSecureContext:window.isSecureContext,hasFocus:document.hasFocus(),userAgent:navigator.userAgent.substring(0,50)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C'})}).catch(()=>{});
            // #endregion
            const filterConfig = getFilterConfig();
            
            // Prompt for optional title
            const title = prompt('Enter a name for this search (optional):');
            if (title === null) return; // User cancelled

            try {
                const response = await fetch('/.netlify/functions/save-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filter_config: filterConfig,
                        title: title || null
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Construct the full URL to copy - be very explicit
                    const shortId = data.saved_search.short_id;
                    const protocol = window.location.protocol;
                    const host = window.location.host;
                    const shortUrl = `${protocol}//${host}/saved/${shortId}`;
                    
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:856',message:'Before clipboard copy',data:{shortUrl:shortUrl,hasFocus:document.hasFocus(),isSecureContext:window.isSecureContext},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,C'})}).catch(()=>{});
                    // #endregion
                    
                    // Update page title if a title was provided
                    if (title && title.trim()) {
                        document.title = `${title} - The Abundant City Policy Atlas`;
                    }
                    
                    // Update URL to the saved search URL
                    window.history.pushState({}, '', `/saved/${shortId}`);
                    
                    // Copy to clipboard - use the most reliable method
                    let copySuccess = false;
                    const textToCopy = shortUrl; // Store in variable to ensure we copy the right thing
                    
                    try {
                        // Try modern clipboard API first
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:872',message:'Attempting clipboard API',data:{hasFocus:document.hasFocus()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B'})}).catch(()=>{});
                            // #endregion
                            await navigator.clipboard.writeText(textToCopy);
                            copySuccess = true;
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:874',message:'Clipboard API succeeded',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B'})}).catch(()=>{});
                            // #endregion
                        } else {
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:876',message:'Clipboard API not available',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
                            // #endregion
                            throw new Error('Clipboard API not available');
                        }
                    } catch (err) {
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:878',message:'Clipboard API failed',data:{errorName:err.name,errorMessage:err.message,errorStack:err.stack?err.stack.substring(0,200):null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,F'})}).catch(()=>{});
                        // #endregion
                        // Fallback: use textarea method
                        try {
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:880',message:'Attempting textarea fallback',data:{hasFocus:document.hasFocus(),activeElement:document.activeElement?document.activeElement.tagName:null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D'})}).catch(()=>{});
                            // #endregion
                            const textArea = document.createElement('textarea');
                            textArea.value = textToCopy;
                            textArea.className = 'clipboard-textarea';
                            textArea.setAttribute('readonly', '');
                            document.body.appendChild(textArea);
                            
                            // Select the text
                            if (navigator.userAgent.match(/ipad|iphone/i)) {
                                // iOS specific
                                const range = document.createRange();
                                range.selectNodeContents(textArea);
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                                textArea.setSelectionRange(0, 999999);
                            } else {
                                textArea.focus();
                                textArea.select();
                            }
                            
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:902',message:'Before execCommand copy',data:{hasFocus:document.hasFocus(),textAreaFocused:textArea===document.activeElement,selectionLength:window.getSelection().toString().length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D'})}).catch(()=>{});
                            // #endregion
                            
                            copySuccess = document.execCommand('copy');
                            
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:902',message:'execCommand result',data:{copySuccess:copySuccess},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D'})}).catch(()=>{});
                            // #endregion
                            
                            document.body.removeChild(textArea);
                        } catch (e) {
                            // #region agent log
                            fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:904',message:'Textarea fallback failed',data:{errorName:e.name,errorMessage:e.message,errorStack:e.stack?e.stack.substring(0,200):null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D,F'})}).catch(()=>{});
                            // #endregion
                            console.error('Copy failed:', e);
                            copySuccess = false;
                        }
                    }
                    
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:910',message:'Final copy result',data:{copySuccess:copySuccess,textToCopy:textToCopy},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E,F'})}).catch(()=>{});
                    // #endregion
                    
                    if (copySuccess) {
                        showToast(`Link copied to clipboard! /saved/${shortId}`);
                    } else {
                        showToast(`Failed to copy. Please copy manually: ${shortUrl}`);
                    }
                } else {
                    showError(data.error || 'Failed to save search');
                }
            } catch (error) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/9614b917-70d0-4ce3-b80a-b7bdea1b71fe',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:918',message:'Save search error',data:{errorName:error.name,errorMessage:error.message},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
                // #endregion
                console.error('Error saving search:', error);
                showError('Failed to save search: ' + error.message);
            }
        }

        function showToast(message) {
            // Create or update toast element
            let toast = document.getElementById('toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast';
                toast.className = 'toast';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.classList.add('toast-visible');
            setTimeout(() => {
                toast.classList.remove('toast-visible');
            }, 3000);
        }

        function renderReforms() {
            reformsList.innerHTML = '';

            if (filteredReforms.length === 0) {
                return;
            }

            filteredReforms.forEach(reform => {
                const card = createReformCard(reform);
                reformsList.appendChild(card);
            });

            // Also render map if in map view
            if (mapView.classList.contains('active')) {
                renderMap();
            }
        }

        function createReformCard(reform, showDistance = false) {
            const card = document.createElement('div');
            card.className = `reform-card ${reform.reform.type}`;

            const adoptionDate = reform.reform.adoption_date || 'Date unknown';
            const placeType = reform.place.type.charAt(0).toUpperCase() + reform.place.type.slice(1);

            const scopeTags = (reform.reform.scope || []).map(s =>
                `<div class="tag">${escapeHtml(s)}</div>`
            ).join('');

            const landUseTags = (reform.reform.land_use || []).map(l =>
                `<div class="tag">${escapeHtml(l)}</div>`
            ).join('');

            const requirementsTags = (reform.reform.requirements || []).map(r =>
                `<div class="tag">${escapeHtml(r)}</div>`
            ).join('');

            // Sources with logos only
            // Use reform.link_url if available, otherwise fall back to source website_url
            const reformLinkUrl = reform.reform.link_url || '';
            const sourcesHtml = (reform.reform.sources && reform.reform.sources.length > 0) ? 
                reform.reform.sources.map(source => {
                    // Use the reform's link_url (tracker URL) if available, otherwise use source website
                    const sourceUrl = reformLinkUrl || source.website_url || '';
                    const logoUrl = source.logo ? `${source.logo}` : '';
                    
                    if (!logoUrl) return '';
                    
                    if (sourceUrl) {
                        return `
                            <a href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener" class="source-logo-link">
                                <img src="${escapeHtml(logoUrl)}" alt="${escapeHtml(source.short_name)}" class="source-logo" />
                            </a>
                        `;
                    } else {
                        return `
                            <img src="${escapeHtml(logoUrl)}" alt="${escapeHtml(source.short_name)}" class="source-logo" />
                        `;
                    }
                }).join('')
            : '';

            card.innerHTML = `
                <div class="reform-header">
                    <h3 class="reform-title">${reform.place.type === 'state' 
                        ? escapeHtml(reform.place.state) 
                        : `${escapeHtml(reform.place.name)}, ${escapeHtml(reform.place.state)}`}</h3>
                    <div class="reform-badges">
                        <span class="badge badge-type">${escapeHtml(reform.reform.type_name)}</span>
                        <span class="badge badge-type">${placeType}</span>
                        ${reform.place.region ? `<span class="badge badge-region">${escapeHtml(reform.place.region)}</span>` : ''}
                    </div>
                </div>

                <div class="reform-meta">
                    <div class="meta-item">
                        <strong>Adopted:</strong> ${adoptionDate}
                    </div>
                    <div class="meta-item">
                        <strong>Status:</strong> ${escapeHtml(reform.reform.status || 'Adopted')}
                    </div>
                    ${reform.reform.policy_document && reform.reform.policy_document.title ? `
                    <div class="meta-item">
                        <strong>Bill Title:</strong> ${escapeHtml(reform.reform.policy_document.title)}
                    </div>
                    ` : ''}
                    ${reform.place.population ? `
                    <div class="meta-item">
                        <strong>Population:</strong> ${parseInt(reform.place.population).toLocaleString()}
                    </div>
                    ` : ''}
                </div>

                ${reform.reform.summary ? `
                <div class="reform-summary">
                    ${escapeHtml(reform.reform.summary)}
                </div>
                ` : ''}

                <div class="reform-details">
                    ${reform.reform.scope.length > 0 ? `
                    <div class="detail-item">
                        <strong>Scope</strong>
                        <div class="tag-list">${scopeTags}</div>
                    </div>
                    ` : ''}
                    
                    ${reform.reform.land_use.length > 0 ? `
                    <div class="detail-item">
                        <strong>Land Use</strong>
                        <div class="tag-list">${landUseTags}</div>
                    </div>
                    ` : ''}

                    ${reform.reform.requirements.length > 0 ? `
                    <div class="detail-item">
                        <strong>Requirements</strong>
                        <div class="tag-list">${requirementsTags}</div>
                    </div>
                    ` : ''}
                </div>

                <div class="reform-footer">
                    <span class="reform-footer-text">
                        ${reform.place.type.charAt(0).toUpperCase() + reform.place.type.slice(1)} ID: ${reform.id}
                    </span>
                    ${sourcesHtml ? `
                    <div class="sources-logos">
                        ${sourcesHtml}
                    </div>
                    ` : ''}
                </div>
            `;

            return card;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            if (show) {
                loadingSpinner.classList.remove('container-hidden');
            } else {
                loadingSpinner.classList.add('container-hidden');
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('container-hidden');
        }

        function hideError() {
            errorMessage.classList.add('container-hidden');
        }

        function switchView(view) {
            if (view === 'list') {
                listView.classList.add('active');
                mapView.classList.remove('active');
                listViewTab.classList.add('active');
                mapViewTab.classList.remove('active');
            } else {
                listView.classList.remove('active');
                mapView.classList.add('active');
                listViewTab.classList.remove('active');
                mapViewTab.classList.add('active');
                initializeMap();
            }
        }

        function initializeMap() {
            if (map) return; // Already initialized

            // Note: Requires Mapbox GL token
            try {
                mapboxgl.accessToken = 'pk.eyJ1IjoiZGFua2VzaGV0IiwiYSI6ImNtazIwdzhpdTBiOWkzZXB3cjEwNmtlbzEifQ.CJh1ehe_-ZmT_SqZxBeL6g'; 
                map = new mapboxgl.Map({
                    container: 'map',
                    style: 'mapbox://styles/mapbox/light-v11',
                    center: [-95.7129, 37.0902], // Center of US
                    zoom: 3.5
                });

                map.on('load', () => {
                    console.log('Map loaded successfully');
                    renderMap();
                });

                // Update markers when map is moved or zoomed
                map.on('moveend', () => {
                    updateMarkersInViewport();
                });
            } catch (e) {
                console.log('Mapbox GL not available. Showing list-only mode.');
                mapView.innerHTML = '<div class="map-error-message">Map view requires Mapbox GL. Please configure your Mapbox token in the code to enable this feature.</div>';
            }
        }

        function renderMap() {
            if (!map || !map.isStyleLoaded()) return;

            // Group reforms by place and create GeoJSON
            const placeReforms = {};
            reformsGeoJSON = [];
            
            filteredReforms.forEach(reform => {
                const placeKey = reform.place.id;
                if (!placeReforms[placeKey]) {
                    placeReforms[placeKey] = [];
                }
                placeReforms[placeKey].push(reform);
            });

            // Convert to GeoJSON features for clustering
            Object.entries(placeReforms).forEach(([placeId, reforms]) => {
                const place = reforms[0].place;
                if (place.latitude && place.longitude) {
                    reformsGeoJSON.push({
                        type: 'Feature',
                        properties: {
                            placeId: placeId,
                            reforms: reforms,
                            reformCount: reforms.length,
                            color: getMarkerColor(reforms[0].reform.type)
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: [place.longitude, place.latitude]
                        }
                    });
                }
            });

            // Initialize Supercluster
            clusterIndex = new Supercluster({
                radius: 60,
                maxZoom: 16,
                minZoom: 0,
                extent: 512,
                nodeSize: 64
            });
            
            clusterIndex.load(reformsGeoJSON);
            
            // Update markers for current viewport
            updateMarkersInViewport();
        }

        function updateMarkersInViewport() {
            if (!map || !clusterIndex) return;

            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // Get clusters and points in current viewport
            const clusters = clusterIndex.getClusters(
                [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()],
                Math.floor(zoom)
            );

            // Clear existing markers
            Object.values(mapMarkers).forEach(marker => marker.remove());
            mapMarkers = {};

            // Add new markers
            clusters.forEach((cluster, idx) => {
                const [lng, lat] = cluster.geometry.coordinates;
                const props = cluster.properties;

                const el = document.createElement('div');
                el.className = 'marker marker-base';

                if (cluster.properties.cluster) {
                    // This is a cluster
                    const pointCount = cluster.properties.point_count;
                    let sizeClass = 'marker-cluster-small';
                    if (pointCount >= 50) {
                        sizeClass = 'marker-cluster-large';
                    } else if (pointCount >= 10) {
                        sizeClass = 'marker-cluster-medium';
                    }
                    
                    el.classList.add('marker-cluster', sizeClass);
                    el.textContent = pointCount;

                    // Zoom into cluster on click
                    el.addEventListener('click', () => {
                        const clusterId = cluster.id;
                        const zoom = clusterIndex.getClusterExpansionZoom(clusterId);
                        map.easeTo({
                            center: [lng, lat],
                            zoom: zoom
                        });
                    });
                } else {
                    // This is an individual place marker
                    el.classList.add('marker-place');
                    el.style.backgroundColor = props.color;

                    el.addEventListener('click', () => {
                        showPlaceOverlay(props.placeId, props.reforms);
                    });
                }

                const marker = new mapboxgl.Marker(el)
                    .setLngLat([lng, lat])
                    .addTo(map);

                mapMarkers[`marker-${idx}`] = marker;
            });
        }

        function getMarkerColor(reformType) {
            // Handle both prefixed (prn:rm_min) and non-prefixed (rm_min) types
            const type = reformType.includes(':') ? reformType.split(':')[1] : reformType;
            switch (type) {
                case 'rm_min': return '#27ae60';
                case 'reduce_min': return '#2ecc71';
                case 'add_max': return '#e74c3c';
                case 'adu': return '#3498db';
                case 'plex': return '#9b59b6';
                case 'tod': return '#f39c12';
                case 'other': return '#95a5a6';
                default: return '#3498db';
            }
        }

        function showPlaceOverlay(placeId, reforms) {
            const place = reforms[0].place;
            document.getElementById('overlayHeader').textContent = `${place.name}, ${place.state} (${reforms.length} reforms)`;
            
            const overlayCards = document.getElementById('overlayCards');
            overlayCards.innerHTML = '';
            reforms.forEach(reform => {
                overlayCards.appendChild(createReformCard(reform, true));
            });

            mapOverlay.classList.add('active');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        async function loadFiltersFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.toString()) {
                const config = urlParamsToFilterConfig(urlParams);
                applyFilterConfig(config);
                return true;
            }
            return false;
        }

        async function loadSavedSearch() {
            const path = window.location.pathname;
            const savedMatch = path.match(/^\/saved\/([a-zA-Z0-9]+)$/);
            if (savedMatch) {
                const shortId = savedMatch[1];
                try {
                    const response = await fetch(`/.netlify/functions/get-saved-search?short_id=${shortId}`);
                    const data = await response.json();

                    if (data.success) {
                        const config = data.saved_search.filter_config;
                        applyFilterConfig(config);
                        
                        // Update page title if saved search has a title
                        if (data.saved_search.title) {
                            document.title = `${data.saved_search.title} - The Abundant City Policy Atlas`;
                        }
                        
                        // Show notification
                        showToast(`Loaded saved search: ${data.saved_search.title || 'Untitled'}`);
                        return true;
                    } else {
                        showError(data.error || 'Saved search not found');
                        // Redirect to home
                        window.history.replaceState({}, '', '/');
                    }
                } catch (error) {
                    console.error('Error loading saved search:', error);
                    showError('Failed to load saved search');
                    window.history.replaceState({}, '', '/');
                }
                return false;
            }
            return false;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await initializeReformTypeFilter();
            initializeLocationFilter();
            updatePopulationLabels();
            updateSliderFill();
            
            // Try to load from saved search first, then URL params, then default
            const loadedSaved = await loadSavedSearch();
            if (!loadedSaved) {
                const loadedFromUrl = await loadFiltersFromUrl();
                if (!loadedFromUrl) {
                    // Apply default filters
                    applyFilters(true);
                } else {
                    // Load from URL params
                    applyFilters(true);
                }
            } else {
                // Loaded from saved search
                applyFilters(true);
            }
        });

        // Handle browser back/forward buttons
        window.addEventListener('popstate', async () => {
            const loadedFromUrl = await loadFiltersFromUrl();
            if (loadedFromUrl) {
                applyFilters(true);
            }
        });
    </script>
</body>
</html>
