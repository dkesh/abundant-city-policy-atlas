<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Abundant City Policy Atlas</title>
    <script src="https://cdn.jsdelivr.net/npm/mapbox-gl@2.15.0/dist/mapbox-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/mapbox-gl@2.15.0/dist/mapbox-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/supercluster@7.1.5/dist/supercluster.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Map-specific overrides */
        .container {
            max-width: 1400px;
        }

        #map {
            width: 100%;
            height: 600px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .map-overlay {
            position: absolute;
            bottom: 40px;
            right: 10px;
            background: white;
            padding: 15px 20px;
            border-radius: 6px;
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
        }

        .map-overlay.active {
            display: block;
        }

        .map-overlay-header {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--color-light);
        }

        .map-overlay-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #7f8c8d;
        }

        /* Mapbox popup styling */
        .mapboxgl-popup-content {
            padding: 0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .popup-text {
            padding: 10px 15px;
            font-size: 14px;
            color: var(--color-text);
            cursor: pointer;
            background: white;
        }

        .popup-text:hover {
            background: var(--color-light);
        }

        @media (max-width: 768px) {
            #map {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="banner.svg" alt="The Abundant City Policy Atlas - Changing Cities By Design" class="banner-img">
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-end; padding: 10px;">
                <a href="about.html" style="color: rgba(255,255,255,0.8); text-decoration: none; padding: 6px 12px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 14px;">About</a>
            </div>
            <!-- Hidden text for accessibility -->
            <div style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;">
                <h1>The Abundant City Policy Atlas</h1>
                <p>Changing Cities By Design</p>
            </div>
        </header>

        <div class="main-content">
            <!-- SIDEBAR FILTERS -->
            <aside class="filters-panel">
                <h2>Filters</h2>

                <!-- Reform Type Filter (Multi-select Checkboxes) -->
                <div class="filter-group">
                    <label>Reform Type</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="reformTypeCheckbox" value="rm_min" checked> Parking mandates eliminated</label>
                        <label><input type="checkbox" class="reformTypeCheckbox" value="reduce_min" checked> Parking mandates reduced</label>
                        <label><input type="checkbox" class="reformTypeCheckbox" value="add_max" checked> Parking maximums</label>
                    </div>
                </div>

                <!-- Jurisdiction Type Filter -->
                <div class="filter-group">
                    <label>Jurisdiction Type</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="placeTypeCheckbox" value="state"> States</label>
                        <label><input type="checkbox" class="placeTypeCheckbox" value="county"> Counties</label>
                        <label><input type="checkbox" class="placeTypeCheckbox" value="city" checked> Cities</label>
                    </div>
                </div>

                <!-- Region/State Filter (Hierarchical) -->
                <div class="filter-group">
                    <label>Location</label>
                    <div class="checkbox-group" id="locationCheckboxes">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Date Range Filter -->
                <div class="filter-group">
                    <label>Adoption Date Range</label>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                        <input type="number" id="fromYear" placeholder="From" min="1900" max="2100" style="width: 80px;">
                        <span>to</span>
                        <input type="number" id="toYear" placeholder="To" min="1900" max="2100" style="width: 80px;">
                    </div>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: normal;">
                        <input type="checkbox" id="includeUnknownDates" checked>
                        <span>Include unknown dates</span>
                    </label>
                </div>

                <!-- Status Filter -->
                <div class="filter-group">
                    <label>Reform Status</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="statusCheckbox" value="adopted" checked> Adopted</label>
                        <label><input type="checkbox" class="statusCheckbox" value="proposed"> Proposed</label>
                        <label><input type="checkbox" class="statusCheckbox" value="failed"> Failed</label>
                    </div>
                </div>

                <!-- Population Filter (Range Slider) -->
                <div class="filter-group">
                    <label>Population Range</label>
                    <div class="slider-container">
                        <input type="range" id="minPopulation" class="range-slider" min="0" max="10000000" value="0" step="10000">
                        <input type="range" id="maxPopulation" class="range-slider" min="0" max="10000000" value="10000000" step="10000">
                    </div>
                    <div class="slider-values">
                        <span id="minPopulationLabel">0</span>
                        <span id="maxPopulationLabel">10,000,000</span>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="filter-buttons">
                    <button class="btn btn-primary" id="applyFilters">Apply Filters</button>
                    <button class="btn btn-secondary" id="resetFilters">Reset</button>
                </div>
            </aside>

            <!-- MAIN CONTENT -->
            <div class="content-area">
                <div id="errorMessage" class="error-message" style="display: none;"></div>

                <!-- View Tabs -->
                <div class="view-tabs">
                    <button class="view-tab active" id="listViewTab">üìã List View</button>
                    <button class="view-tab" id="mapViewTab">üó∫Ô∏è Map View</button>
                </div>

                <!-- Results Info -->
                <div id="resultsInfo" class="results-info" style="display: none;">
                    <p>Found <strong id="resultCount">0</strong> reforms matching your filters</p>
                </div>

                <!-- Loading Spinner -->
                <div id="loadingSpinner" class="loading" style="display: none;">
                    <div class="loading-spinner"></div>
                    <p>Loading reforms...</p>
                </div>

                <!-- LIST VIEW -->
                <div id="listView" class="view-container active">
                    <div id="reformsList" class="reforms-list"></div>
                    <div id="noResultsList" class="no-results" style="display: none;">
                        <h3>No Reforms Found</h3>
                        <p>Try adjusting your filters to see more results.</p>
                    </div>
                </div>

                <!-- MAP VIEW -->
                <div id="mapView" class="view-container">
                    <div id="map"></div>
                    <div id="mapOverlay" class="map-overlay">
                        <button class="map-overlay-close" id="closeOverlay">‚úï</button>
                        <div class="map-overlay-header" id="overlayHeader"></div>
                        <div id="overlayCards" class="reforms-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let allReforms = [];
        let filteredReforms = [];
        let map = null;
        let mapMarkers = {};
        let clusterIndex = null;
        let reformsGeoJSON = [];
        const REGIONS = {
            'Northeast': ['Connecticut', 'Maine', 'Massachusetts', 'New Hampshire', 'Rhode Island', 'Vermont', 'New Jersey', 'New York', 'Pennsylvania'],
            'Midwest': ['Illinois', 'Indiana', 'Michigan', 'Ohio', 'Wisconsin', 'Iowa', 'Kansas', 'Minnesota', 'Missouri', 'Nebraska', 'North Dakota', 'South Dakota'],
            'South': ['Delaware', 'Florida', 'Georgia', 'Maryland', 'North Carolina', 'South Carolina', 'Virginia', 'West Virginia', 'Alabama', 'Kentucky', 'Mississippi', 'Tennessee', 'Arkansas', 'Louisiana', 'Oklahoma', 'Texas', 'District of Columbia'],
            'West': ['Arizona', 'Colorado', 'Idaho', 'Montana', 'Nevada', 'New Mexico', 'Utah', 'Wyoming', 'Alaska', 'California', 'Hawaii', 'Oregon', 'Washington']
        };

        // ============================================================================
        // UI ELEMENTS
        // ============================================================================

        const reformTypeCheckboxes = document.querySelectorAll('.reformTypeCheckbox');
        const placeTypeCheckboxes = document.querySelectorAll('.placeTypeCheckbox');
        const statusCheckboxes = document.querySelectorAll('.statusCheckbox');
        const minPopulationSlider = document.getElementById('minPopulation');
        const maxPopulationSlider = document.getElementById('maxPopulation');
        const minPopulationLabel = document.getElementById('minPopulationLabel');
        const maxPopulationLabel = document.getElementById('maxPopulationLabel');
        const locationCheckboxes = document.getElementById('locationCheckboxes');
        const fromYear = document.getElementById('fromYear');
        const toYear = document.getElementById('toYear');
        const includeUnknownDates = document.getElementById('includeUnknownDates');
        const applyFiltersBtn = document.getElementById('applyFilters');
        const resetFiltersBtn = document.getElementById('resetFilters');
        const reformsList = document.getElementById('reformsList');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resultsInfo = document.getElementById('resultsInfo');
        const resultCount = document.getElementById('resultCount');
        const noResultsList = document.getElementById('noResultsList');
        const errorMessage = document.getElementById('errorMessage');
        const listViewTab = document.getElementById('listViewTab');
        const mapViewTab = document.getElementById('mapViewTab');
        const listView = document.getElementById('listView');
        const mapView = document.getElementById('mapView');
        const mapOverlay = document.getElementById('mapOverlay');
        const closeOverlayBtn = document.getElementById('closeOverlay');

        // ============================================================================
        // EVENT LISTENERS
        // ============================================================================

        applyFiltersBtn.addEventListener('click', applyFilters);
        resetFiltersBtn.addEventListener('click', resetFilters);
        listViewTab.addEventListener('click', () => switchView('list'));
        mapViewTab.addEventListener('click', () => switchView('map'));
        closeOverlayBtn.addEventListener('click', () => mapOverlay.classList.remove('active'));

        // Population slider synchronization
        minPopulationSlider.addEventListener('input', () => {
            if (parseInt(minPopulationSlider.value) > parseInt(maxPopulationSlider.value)) {
                maxPopulationSlider.value = minPopulationSlider.value;
            }
            updatePopulationLabels();
        });

        maxPopulationSlider.addEventListener('input', () => {
            if (parseInt(maxPopulationSlider.value) < parseInt(minPopulationSlider.value)) {
                minPopulationSlider.value = maxPopulationSlider.value;
            }
            updatePopulationLabels();
        });

        // ============================================================================
        // FUNCTIONS
        // ============================================================================

        function updatePopulationLabels() {
            const min = parseInt(minPopulationSlider.value);
            const max = parseInt(maxPopulationSlider.value);
            minPopulationLabel.textContent = min.toLocaleString();
            maxPopulationLabel.textContent = max.toLocaleString();
        }

        async function initializeReformTypeFilter() {
            try {
                const response = await fetch('/.netlify/functions/get-reform-types');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch reform types');
                }

                const container = document.querySelector('.filter-group .checkbox-group');
                container.innerHTML = '';

                // Group Types by Category
                const byCategory = {};
                data.reformTypes.forEach(rt => {
                    const cat = rt.category || 'Other';
                    if (!byCategory[cat]) byCategory[cat] = [];
                    byCategory[cat].push(rt);
                });

                // Define order
                const catOrder = ['Parking', 'Housing Types', 'Process', 'Land Use', 'Building Code', 'Other'];

                // Render Groups
                catOrder.forEach(cat => {
                    if (!byCategory[cat]) return;

                    // 1. Create Header (Chevron + Checkbox + Label)
                    const catHeader = document.createElement('div');
                    catHeader.className = 'category-header'; // Reuses region-header style via CSS

                    // Chevron
                    const chevron = document.createElement('span');
                    chevron.className = 'chevron';
                    chevron.textContent = '‚ñº';
                    chevron.style.transform = 'rotate(-90deg)'; // Start collapsed
                    
                    // Label wrapper
                    const labelGroup = document.createElement('label');
                    labelGroup.className = 'category-group'; // Reuses region-group style
                    labelGroup.style.display = 'flex';
                    labelGroup.style.alignItems = 'center';
                    labelGroup.style.fontWeight = '600';
                    
                    // Parent Checkbox
                    const parentCb = document.createElement('input');
                    parentCb.type = 'checkbox';
                    parentCb.className = 'category-cb';
                    parentCb.checked = true;
                    parentCb.dataset.category = cat;
                    parentCb.addEventListener('change', (e) => updateReformHierarchy(e.target));

                    labelGroup.appendChild(parentCb);
                    labelGroup.appendChild(document.createTextNode(' ' + cat));

                    catHeader.appendChild(chevron);
                    catHeader.appendChild(labelGroup);
                    container.appendChild(catHeader);

                    // 2. Create Reform Items Container (Hidden by default)
                    const reformsContainer = document.createElement('div');
                    reformsContainer.className = 'reforms-container'; // Reuses states-container style
                    reformsContainer.style.display = 'none';

                    // Items
                    byCategory[cat].forEach(rt => {
                        const label = document.createElement('label');
                        label.className = 'reform-item'; // Reuses state-item style
                        label.style.display = 'flex';
                        label.style.alignItems = 'center';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'reformTypeCheckbox';
                        checkbox.value = rt.code;
                        checkbox.checked = true;
                        checkbox.dataset.category = cat;
                        checkbox.dataset.color = rt.color_hex;
                        checkbox.addEventListener('change', (e) => updateCategoryCheckbox(e.target));
                        
                        // Color indicator
                        if (rt.color_hex) {
                           label.style.borderLeft = `3px solid ${rt.color_hex}`;
                           label.style.paddingLeft = '5px'; // slightly adjusted
                        }

                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(' ' + rt.name));
                        reformsContainer.appendChild(label);
                    });
                    
                    container.appendChild(reformsContainer);

                    // Toggle click handler
                    chevron.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = reformsContainer.style.display === 'none';
                        reformsContainer.style.display = isHidden ? 'block' : 'none';
                        chevron.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
                    });
                });
            } catch (error) {
                console.error('Error loading reform types:', error);
                showError('Failed to load reform types');
            }
        }

        function getSelectedReformTypes() {
            const checkboxes = document.querySelectorAll('.reformTypeCheckbox');
            const selected = [];
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedPlaceTypes() {
            const selected = [];
            placeTypeCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedStatuses() {
            const selected = [];
            statusCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.value);
                }
            });
            return selected;
        }

        function getSelectedLocations() {
            const checkboxes = document.querySelectorAll('#locationCheckboxes input[data-state]:checked');
            const states = [];
            checkboxes.forEach(cb => {
                if (cb.dataset.state) {
                    states.push(cb.dataset.state);
                }
            });
            return states;
        }

        function updateLocationHierarchy(regionCheckbox) {
            const region = regionCheckbox.dataset.region;
            const states = REGIONS[region];
            const stateCheckboxes = document.querySelectorAll(
                `#locationCheckboxes input[data-state][data-region="${region}"]`
            );

            stateCheckboxes.forEach(cb => {
                cb.checked = regionCheckbox.checked;
            });
        }

        function updateRegionCheckbox(stateCheckbox) {
            const region = stateCheckbox.dataset.region;
            const regionCheckbox = document.querySelector(
                `#locationCheckboxes input[data-region="${region}"]:not([data-state])`
            );

            if (!regionCheckbox) return;

            const stateCheckboxes = document.querySelectorAll(
                `#locationCheckboxes input[data-state][data-region="${region}"]`
            );
            const allChecked = Array.from(stateCheckboxes).every(cb => cb.checked);
            const someChecked = Array.from(stateCheckboxes).some(cb => cb.checked);

            regionCheckbox.checked = allChecked;
            regionCheckbox.indeterminate = someChecked && !allChecked;
        }

        // --- Reform Type Hierarchy Helpers ---

        function updateReformHierarchy(categoryCheckbox) {
            const category = categoryCheckbox.dataset.category;
            const reformCheckboxes = document.querySelectorAll(
                `.reformTypeCheckbox[data-category="${category}"]`
            );

            reformCheckboxes.forEach(cb => {
                cb.checked = categoryCheckbox.checked;
            });
        }

        function updateCategoryCheckbox(reformCheckbox) {
            const category = reformCheckbox.dataset.category;
            // Find parent category checkbox (it has data-category but NOT class 'reformTypeCheckbox' in my new design, 
            // or I can give it a specific class like 'category-cb')
            const categoryCheckbox = document.querySelector(
                `input.category-cb[data-category="${category}"]`
            );

            if (!categoryCheckbox) return;

            const siblings = document.querySelectorAll(
                `.reformTypeCheckbox[data-category="${category}"]`
            );
            const allChecked = Array.from(siblings).every(cb => cb.checked);
            const someChecked = Array.from(siblings).some(cb => cb.checked);

            categoryCheckbox.checked = allChecked;
            categoryCheckbox.indeterminate = someChecked && !allChecked;
        }

        function initializeLocationFilter() {
            locationCheckboxes.innerHTML = '';

            Object.keys(REGIONS).forEach(region => {
                // Region container
                const regionHeader = document.createElement('div');
                regionHeader.className = 'region-header';
                
                // Region checkbox label
                const regionLabel = document.createElement('label');
                regionLabel.className = 'region-group';
                const regionCheckbox = document.createElement('input');
                regionCheckbox.type = 'checkbox';
                regionCheckbox.dataset.region = region;
                regionCheckbox.addEventListener('change', (e) => updateLocationHierarchy(e.target));
                regionLabel.appendChild(regionCheckbox);
                regionLabel.appendChild(document.createTextNode(' ' + region));
                
                // Chevron toggle
                const chevron = document.createElement('span');
                chevron.className = 'chevron';
                chevron.textContent = '‚ñº';
                // Start collapsed
                chevron.style.transform = 'rotate(-90deg)';
                
                // Header gets chevron + label (chevron on left)
                regionHeader.appendChild(chevron);
                regionHeader.appendChild(regionLabel);
                locationCheckboxes.appendChild(regionHeader);

                // States container (hidden by default)
                const statesContainer = document.createElement('div');
                statesContainer.className = 'states-container';
                statesContainer.style.display = 'none';

                REGIONS[region].forEach(state => {
                    const stateLabel = document.createElement('label');
                    stateLabel.className = 'state-item';
                    const stateCheckbox = document.createElement('input');
                    stateCheckbox.type = 'checkbox';
                    stateCheckbox.dataset.state = state;
                    stateCheckbox.dataset.region = region;
                    stateCheckbox.addEventListener('change', (e) => updateRegionCheckbox(e.target));
                    stateLabel.appendChild(stateCheckbox);
                    stateLabel.appendChild(document.createTextNode(' ' + state));
                    statesContainer.appendChild(stateLabel);
                });
                
                locationCheckboxes.appendChild(statesContainer);

                // Toggle click handler
                chevron.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = statesContainer.style.display === 'none';
                    statesContainer.style.display = isHidden ? 'block' : 'none';
                    chevron.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
                });
            });
        }

        async function applyFilters() {
            const reformTypes = getSelectedReformTypes();
            const placeTypes = getSelectedPlaceTypes();
            const statuses = getSelectedStatuses();
            const minPopulation = parseInt(minPopulationSlider.value);
            const maxPopulation = parseInt(maxPopulationSlider.value);
            const states = getSelectedLocations();
            const fromYearVal = fromYear.value ? parseInt(fromYear.value) : null;
            const toYearVal = toYear.value ? parseInt(toYear.value) : null;
            const includeUnknown = includeUnknownDates.checked;

            showLoading(true);
            hideError();

            try {
                // Build query string
                const params = new URLSearchParams();
                reformTypes.forEach(t => params.append('reform_type', t));
                placeTypes.forEach(t => params.append('place_type', t));
                statuses.forEach(s => params.append('status', s));
                if (minPopulation > 0) params.append('min_population', minPopulation);
                if (maxPopulation < 10000000) params.append('max_population', maxPopulation);
                states.forEach(s => params.append('state', s));
                if (fromYearVal) params.append('from_year', fromYearVal);
                if (toYearVal) params.append('to_year', toYearVal);
                if (includeUnknown) params.append('include_unknown_dates', 'true');

                const query = params.toString();
                const url = query ? `/.netlify/functions/get-reforms?${query}` : '/.netlify/functions/get-reforms';

                // Fetch reforms
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch reforms');
                }

                allReforms = data.reforms;
                filteredReforms = allReforms;

                renderReforms();
                showLoading(false);

                if (filteredReforms.length > 0) {
                    resultsInfo.style.display = 'flex';
                    resultCount.textContent = filteredReforms.length;
                    noResultsList.style.display = 'none';
                } else {
                    resultsInfo.style.display = 'none';
                    noResultsList.style.display = 'block';
                }

            } catch (error) {
                console.error('Error:', error);
                showError(error.message);
                showLoading(false);
                resultsInfo.style.display = 'none';
                noResultsList.style.display = 'block';
            }
        }

        function resetFilters() {
            // Reset checkboxes
            document.querySelectorAll('.reformTypeCheckbox').forEach(cb => cb.checked = true);
            document.querySelectorAll('.category-cb').forEach(cb => {
                cb.checked = true;
                cb.indeterminate = false;
            });
            placeTypeCheckboxes.forEach(cb => {
                cb.checked = cb.value === 'city';
            });
            statusCheckboxes.forEach(cb => {
                cb.checked = cb.value === 'adopted';
            });
            document.querySelectorAll('#locationCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = false);

            // Reset sliders
            minPopulationSlider.value = 0;
            maxPopulationSlider.value = 10000000;
            updatePopulationLabels();

            // Reset date range
            fromYear.value = '';
            toYear.value = '';
            includeUnknownDates.checked = true;

            applyFilters();
        }

        function renderReforms() {
            reformsList.innerHTML = '';

            if (filteredReforms.length === 0) {
                return;
            }

            filteredReforms.forEach(reform => {
                const card = createReformCard(reform);
                reformsList.appendChild(card);
            });

            // Also render map if in map view
            if (mapView.classList.contains('active')) {
                renderMap();
            }
        }

        function createReformCard(reform, showDistance = false) {
            const card = document.createElement('div');
            card.className = `reform-card ${reform.reform.type}`;

            const adoptionDate = reform.reform.adoption_date || 'Date unknown';
            const placeType = reform.place.type.charAt(0).toUpperCase() + reform.place.type.slice(1);

            const scopeTags = (reform.reform.scope || []).map(s =>
                `<div class="tag">${escapeHtml(s)}</div>`
            ).join('');

            const landUseTags = (reform.reform.land_use || []).map(l =>
                `<div class="tag">${escapeHtml(l)}</div>`
            ).join('');

            const requirementsTags = (reform.reform.requirements || []).map(r =>
                `<div class="tag">${escapeHtml(r)}</div>`
            ).join('');

            // Sources with logos and reporters
            const sourcesHtml = (reform.reform.sources && reform.reform.sources.length > 0) ? 
                reform.reform.sources.map(source => {
                    const reporterInfo = source.reporter ? `<span class="source-reporter">${escapeHtml(source.reporter)}</span>` : '';
                    const sourceUrl = source.source_url || source.website_url || '';
                    const logoUrl = source.logo ? `${source.logo}` : '';
                    
                    if (sourceUrl) {
                        return `
                            <a href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener" class="source-badge">
                                ${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="${escapeHtml(source.short_name)}" class="source-logo" />` : ''}
                                <span class="source-name">${escapeHtml(source.short_name)}</span>
                                ${reporterInfo}
                            </a>
                        `;
                    } else {
                        return `
                            <div class="source-badge">
                                ${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="${escapeHtml(source.short_name)}" class="source-logo" />` : ''}
                                <span class="source-name">${escapeHtml(source.short_name)}</span>
                                ${reporterInfo}
                            </div>
                        `;
                    }
                }).join('')
            : '';

            card.innerHTML = `
                <div class="reform-header">
                    <h3 class="reform-title">${escapeHtml(reform.place.name)}, ${escapeHtml(reform.place.state)}</h3>
                    <div class="reform-badges">
                        <span class="badge badge-type">${escapeHtml(reform.reform.type_name)}</span>
                        <span class="badge badge-type">${placeType}</span>
                        ${reform.place.region ? `<span class="badge badge-region">${escapeHtml(reform.place.region)}</span>` : ''}
                    </div>
                </div>

                <div class="reform-meta">
                    <div class="meta-item">
                        <strong>Adopted:</strong> ${adoptionDate}
                    </div>
                    <div class="meta-item">
                        <strong>Status:</strong> ${escapeHtml(reform.reform.status || 'Adopted')}
                    </div>
                    ${reform.place.population ? `
                    <div class="meta-item">
                        <strong>Population:</strong> ${parseInt(reform.place.population).toLocaleString()}
                    </div>
                    ` : ''}
                </div>

                ${reform.reform.summary ? `
                <div class="reform-summary">
                    ${escapeHtml(reform.reform.summary)}
                </div>
                ` : ''}

                <div class="reform-details">
                    ${reform.reform.scope.length > 0 ? `
                    <div class="detail-item">
                        <strong>Scope</strong>
                        <div class="tag-list">${scopeTags}</div>
                    </div>
                    ` : ''}
                    
                    ${reform.reform.land_use.length > 0 ? `
                    <div class="detail-item">
                        <strong>Land Use</strong>
                        <div class="tag-list">${landUseTags}</div>
                    </div>
                    ` : ''}

                    ${reform.reform.requirements.length > 0 ? `
                    <div class="detail-item">
                        <strong>Requirements</strong>
                        <div class="tag-list">${requirementsTags}</div>
                    </div>
                    ` : ''}
                </div>

                ${sourcesHtml ? `
                <div class="sources-section">
                    <strong>Data Sources</strong>
                    <div class="sources-list">
                        ${sourcesHtml}
                    </div>
                </div>
                ` : ''}

                <div class="reform-footer">
                    <span style="color: #95a5a6; font-size: 11px;">
                        ${reform.place.type.charAt(0).toUpperCase() + reform.place.type.slice(1)} ID: ${reform.id}
                    </span>
                </div>
            `;

            return card;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            loadingSpinner.style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        function switchView(view) {
            if (view === 'list') {
                listView.classList.add('active');
                mapView.classList.remove('active');
                listViewTab.classList.add('active');
                mapViewTab.classList.remove('active');
            } else {
                listView.classList.remove('active');
                mapView.classList.add('active');
                listViewTab.classList.remove('active');
                mapViewTab.classList.add('active');
                initializeMap();
            }
        }

        function initializeMap() {
            if (map) return; // Already initialized

            // Note: Requires Mapbox GL token
            try {
                mapboxgl.accessToken = 'pk.eyJ1IjoiZGFua2VzaGV0IiwiYSI6ImNtazIwdzhpdTBiOWkzZXB3cjEwNmtlbzEifQ.CJh1ehe_-ZmT_SqZxBeL6g'; 
                map = new mapboxgl.Map({
                    container: 'map',
                    style: 'mapbox://styles/mapbox/light-v11',
                    center: [-95.7129, 37.0902], // Center of US
                    zoom: 3.5
                });

                map.on('load', () => {
                    console.log('Map loaded successfully');
                    renderMap();
                });

                // Update markers when map is moved or zoomed
                map.on('moveend', () => {
                    updateMarkersInViewport();
                });
            } catch (e) {
                console.log('Mapbox GL not available. Showing list-only mode.');
                mapView.innerHTML = '<div style="padding: 40px; text-align: center; color: #7f8c8d;">Map view requires Mapbox GL. Please configure your Mapbox token in the code to enable this feature.</div>';
            }
        }

        function renderMap() {
            if (!map || !map.isStyleLoaded()) return;

            // Group reforms by place and create GeoJSON
            const placeReforms = {};
            reformsGeoJSON = [];
            
            filteredReforms.forEach(reform => {
                const placeKey = reform.place.id;
                if (!placeReforms[placeKey]) {
                    placeReforms[placeKey] = [];
                }
                placeReforms[placeKey].push(reform);
            });

            // Convert to GeoJSON features for clustering
            Object.entries(placeReforms).forEach(([placeId, reforms]) => {
                const place = reforms[0].place;
                if (place.latitude && place.longitude) {
                    reformsGeoJSON.push({
                        type: 'Feature',
                        properties: {
                            placeId: placeId,
                            reforms: reforms,
                            reformCount: reforms.length,
                            color: getMarkerColor(reforms[0].reform.type)
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: [place.longitude, place.latitude]
                        }
                    });
                }
            });

            // Initialize Supercluster
            clusterIndex = new Supercluster({
                radius: 60,
                maxZoom: 16,
                minZoom: 0,
                extent: 512,
                nodeSize: 64
            });
            
            clusterIndex.load(reformsGeoJSON);
            
            // Update markers for current viewport
            updateMarkersInViewport();
        }

        function updateMarkersInViewport() {
            if (!map || !clusterIndex) return;

            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // Get clusters and points in current viewport
            const clusters = clusterIndex.getClusters(
                [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()],
                Math.floor(zoom)
            );

            // Clear existing markers
            Object.values(mapMarkers).forEach(marker => marker.remove());
            mapMarkers = {};

            // Add new markers
            clusters.forEach((cluster, idx) => {
                const [lng, lat] = cluster.geometry.coordinates;
                const props = cluster.properties;

                const el = document.createElement('div');
                el.className = 'marker';
                el.style.cursor = 'pointer';
                el.style.border = '2px solid white';
                el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';

                if (cluster.properties.cluster) {
                    // This is a cluster
                    const pointCount = cluster.properties.point_count;
                    const size = pointCount < 10 ? 30 : pointCount < 50 ? 40 : 50;
                    
                    el.style.width = `${size}px`;
                    el.style.height = `${size}px`;
                    el.style.borderRadius = '50%';
                    el.style.backgroundColor = '#3498db';
                    el.style.display = 'flex';
                    el.style.alignItems = 'center';
                    el.style.justifyContent = 'center';
                    el.style.color = 'white';
                    el.style.fontWeight = 'bold';
                    el.style.fontSize = '12px';
                    el.textContent = pointCount;

                    // Zoom into cluster on click
                    el.addEventListener('click', () => {
                        const clusterId = cluster.id;
                        const zoom = clusterIndex.getClusterExpansionZoom(clusterId);
                        map.easeTo({
                            center: [lng, lat],
                            zoom: zoom
                        });
                    });
                } else {
                    // This is an individual place marker
                    el.style.backgroundColor = props.color;
                    el.style.width = '24px';
                    el.style.height = '24px';
                    el.style.borderRadius = '50%';

                    el.addEventListener('click', () => {
                        showPlaceOverlay(props.placeId, props.reforms);
                    });
                }

                const marker = new mapboxgl.Marker(el)
                    .setLngLat([lng, lat])
                    .addTo(map);

                mapMarkers[`marker-${idx}`] = marker;
            });
        }

        function getMarkerColor(reformType) {
            // Handle both prefixed (prn:rm_min) and non-prefixed (rm_min) types
            const type = reformType.includes(':') ? reformType.split(':')[1] : reformType;
            switch (type) {
                case 'rm_min': return '#27ae60';
                case 'reduce_min': return '#2ecc71';
                case 'add_max': return '#e74c3c';
                case 'adu': return '#3498db';
                case 'plex': return '#9b59b6';
                case 'tod': return '#f39c12';
                case 'other': return '#95a5a6';
                default: return '#3498db';
            }
        }

        function showPlaceOverlay(placeId, reforms) {
            const place = reforms[0].place;
            document.getElementById('overlayHeader').textContent = `${place.name}, ${place.state} (${reforms.length} reforms)`;
            
            const overlayCards = document.getElementById('overlayCards');
            overlayCards.innerHTML = '';
            reforms.forEach(reform => {
                overlayCards.appendChild(createReformCard(reform, true));
            });

            mapOverlay.classList.add('active');
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        document.addEventListener('DOMContentLoaded', async () => {
            await initializeReformTypeFilter();
            initializeLocationFilter();
            updatePopulationLabels();
            applyFilters(); // Load initial data
        });
    </script>
</body>
</html>
